#include <iostream>
using namespace std;
#include<stdlib.h>
#include<time.h>
#include<math.h>
#include<stdio.h>
#include<string.h>
#define IntronLength 10

//static long long P = 999999999961; long long G = 29;
//static long long P = 99881; long long G = 6;
static long long P = 257; long long G = 3;
static char Q[16]= {'A','B','C','D','E','F','G','H','I','J','K','L','M','N','O','P'};
static char R[16]= {'!','@','#','$','%','^','&','*','(',')','?','<','>','{','}','+'};
long long Ya,Yb;

long long Diffie_Hellman(long long Y,long long X)
{
    long long temp,temp1;
    temp1=pow(Y,X);
    temp=temp1%P;
    //if(temp<0)
    //temp+=P;
    return temp;
}

long long ExchangeKeys()
{
    long long Xa=0,Xb=0;
    long long t=9;
    long long PKa=0,PKb=0;
    Xa=rand()%t;    //Random Number Generated by Sender
    //cout<<"Xa = "<<Xa<<endl;
    Xb=rand()%t;    //Random Number Generated by Receiver
    //cout<<"Xb = "<<Xb<<endl;
    Ya=((long long)pow(G,Xa))%P;    //Done by Sender
    Yb=((long long)pow(G,Xb))%P;    //Done by Receiver
   //cout <<"Ya = "<<Ya<<endl<<"Yb = "<<Yb<<endl;
    PKa=Diffie_Hellman(Yb,Xa);
    PKb=Diffie_Hellman(Ya,Xb);
    //cout<<"PKa="<<PKa<<endl;
    //cout<<"PKb="<<PKb<<endl<<endl;
    if(PKa==PKb)
    {
        return PKa;
    }
    else
    {
        return 1;
    }
}

long long BinaryCompliment(long long n)
{
    long long temp,ctr=0;
    temp=n;
    while(temp)
    {
        temp=temp/2;
        ctr++;
    }
    return (~n&(long long)(pow(2,ctr)-1));
}

/***LEVEL  1 ENCRYPTION***/
void ProcedureEncryptionLevel1(long long PK1, char* data, char *tempdata)
{
    char EncryptedData[1000000];
    int i;
    long long n1,n2;
    long long q,r;
    char read;
    //cout<<"Original data :"<<data<<endl;
    for(i=0; data[i]!='\0'; i++)
    {
        n1=data[i]/16;
        n2=data[i]%16;
        q=(n1+PK1)%16;
        r=(n2+PK1)%16;
        EncryptedData[2*i]=Q[q];
        EncryptedData[(2*i)+1]=R[r];
    }
    EncryptedData[2*i]='\0';
    //cout<<EncryptedData;
    strcpy(tempdata, EncryptedData);
   // fprintf(fp,"%s",EncryptedData);
    //fclose(fp);
    //return EncryptedData;
}
/*****************************/

/***LEVEL 2 ENCRYPTION***/
void ProcedureEncryptionLevel2(long long Level2Key, char* data, char *tempdata, char *AUT, char *FT, char *INTR)
{
    int i;
    long long temp;
    long long ctr=0;
    char cipher[1000000];
    temp=Level2Key;
    long long sum=0;
    FILE *fp;
    fp=fopen("encodedfile.txt","w");

    while(temp>0)
    {
        sum+=temp%10;
        temp=temp/10;
    }
    if(sum%2==1)
    sum+=1;
    //if(sum<5)
    //sum=5;

    char SPM[sum],EPM[sum];     //Starting Primer-SPM; Ending Primer-EPM

    for(i=1;i<sum;i+=2)
    {
        SPM[i-1]=Q[rand()%16];
        SPM[i]=R[rand()%16];
        EPM[i-1]=Q[rand()%16];
        EPM[i]=R[rand()%16];
    }
    SPM[i-1]='\0';
    EPM[i-1]='\0';

    //cout<<"SPM- "<<SPM<<"\n"<<"EPM- "<<EPM<<"\n";
    /**Generating Level 2 cipher Text**/
    long long k=0;
    //Attaching Starting Primer to Level 1 cipher text
    for(i=0;SPM[i]!='\0';i++)
    {
        cipher[ctr++]=SPM[i];
    }

    //cout<<"sum="<<sum<<endl<<"Level2Key="<<Level2Key<<endl;
    long long pos1=(2*Level2Key)/sum;
    long long pos2=(3*Level2Key)/sum;
    long long pos3=(4*Level2Key)/sum;

    if(pos1%2==1)
    pos1=pos1+1;
    if(pos2%2==1)
    pos2=pos2+1;
    if(pos3%2==1)
    pos3=pos3+1;

    //cout<<"pos1="<<pos1<<endl<<"pos2="<<pos2<<endl<<"pos3="<<pos3<<endl;

    while(k<pos1)
    {
        cipher[ctr++]=data[k++];
    }
    //Attaching AUT to Level 1 cipher text
    for(int j=0;j<IntronLength;j++)
    {
        cipher[ctr++]=AUT[j];
    }

    while(k<pos2)
    {
        cipher[ctr++]=data[k++];
    }
    //Attaching FT to Level 1 cipher text
    for(int j=0;j<IntronLength;j++)
    {
        cipher[ctr++]=FT[j];
    }

    while(k<pos3)
    {
        cipher[ctr++]=data[k++];
    }
    //Attaching INTR to level 1 cipher text
    for(int j=0;j<IntronLength;j++)
    {
        cipher[ctr++]=INTR[j];
    }

    while(data[k]!='\0')
    {
        cipher[ctr++]=data[k++];
    }

    //Attaching Ending Primer to Level 1 cipher text
    for(i=0;EPM[i]!='\0';i++)
    {
        cipher[ctr++]=EPM[i];
    }
    cipher[ctr]='\0';
    /************************************/
    //cout<<cipher<<endl<<endl;
    fprintf(fp,"%s",cipher);
    fclose(fp);
    strcpy(tempdata,cipher);
}
/*****************************/

/**DECRYPTION**/
void ProcedureDecryption(long long PK1, char *EncryptedData, long long  L2Key)
{
    cout<<"Key for Decryption = "<<PK1<<endl;
    int i,j;
    long long q,r;
    long long n1,n2;
    int ByteCode;
    char DecryptedData[1000000];
    long long ctr=0;
    FILE *fp;
    fp=fopen("decryptedfile.txt","w");
    //cout<<EncryptedData<<endl<<endl;
    long long temp=L2Key;
    long long sum=0;
    while(temp>0)
    {
        sum+=temp%10;
        temp=temp/10;
    }
    if(sum%2==1)
    sum+=1;
    //if(sum<5)
    //sum=5;

    long long pos1=(2*L2Key)/sum;
    long long pos2=(3*L2Key)/sum;
    long long pos3=(4*L2Key)/sum;

    if(pos1%2==1)
    pos1=pos1+1;
    if(pos2%2==1)
    pos2=pos2+1;
    if(pos3%2==1)
    pos3=pos3+1;

    //cout<<"sum="<<sum<<endl<<"Level2Key="<<L2Key<<endl;
    //cout<<"pos1="<<pos1<<endl<<"pos2="<<pos2<<endl<<"pos3="<<pos3<<endl;

    //cout<<"DECRYPTED DATA\n";
    for(i=0; EncryptedData[i]!='\0'; i+=2)
    {
        if((i==0)||(EncryptedData[i+sum]=='\0'))
        {
            i+=sum-2;
            continue;
        }
        if(i==pos1+sum)
        {
           int k=i;
            cout<<"Authentication Code: ";
            while(k<(i+IntronLength))
            {
                for(j=0; j<16; j++)
                {
                    if(Q[j]==EncryptedData[k])
                    {
                        q=j;
                        break;
                    }
                }
                for(j=0; j<16; j++)
                {
                    if(R[j]==EncryptedData[k+1])
                    {
                        r=j;
                        break;
                    }
                }
                n1=q-PK1;
                n1=n1%16;
                if(n1<0)
                n1+=16;
                n2=r-PK1;
                n2=n2%16;
                if(n2<0)
                n2+=16;
                ByteCode=(n1*16)+n2;
                cout<<(char)ByteCode;
                k+=2;
            }
            cout<<"\n";
            i+=IntronLength-2;
            continue;
        }
        if(i==pos2+sum+IntronLength)
        {
            int k=i;
            cout<<"File Type Code: ";
            while(k<(i+IntronLength))
            {
                for(j=0; j<16; j++)
                {
                    if(Q[j]==EncryptedData[k])
                    {
                        q=j;
                        break;
                    }
                }
                for(j=0; j<16; j++)
                {
                    if(R[j]==EncryptedData[k+1])
                    {
                        r=j;
                        break;
                    }
                }
                n1=q-PK1;
                n1=n1%16;
                if(n1<0)
                n1+=16;
                n2=r-PK1;
                n2=n2%16;
                if(n2<0)
                n2+=16;
                ByteCode=(n1*16)+n2;
                cout<<(char)ByteCode;
                k+=2;
            }
            cout<<"\n";
            i+=IntronLength-2;
            continue;
        }
        if(i==pos3+sum+(2*IntronLength))
        {
            int k=i;
            cout<<"Integrity Code: ";
            while(k<(i+IntronLength))
            {
                for(j=0; j<16; j++)
                {
                    if(Q[j]==EncryptedData[k])
                    {
                        q=j;
                        break;
                    }
                }
                for(j=0; j<16; j++)
                {
                    if(R[j]==EncryptedData[k+1])
                    {
                        r=j;
                        break;
                    }
                }
                n1=q-PK1;
                n1=n1%16;
                if(n1<0)
                n1+=16;
                n2=r-PK1;
                n2=n2%16;
                if(n2<0)
                n2+=16;
                ByteCode=(n1*16)+n2;
                cout<<(char)ByteCode;
                k+=2;
            }
            cout<<"\n";
            i+=IntronLength-2;
            continue;
        }

        for(j=0; j<16; j++)
        {
            if(Q[j]==EncryptedData[i])
            {
                q=j;
                break;
            }
        }
        for(j=0; j<16; j++)
        {
            if(R[j]==EncryptedData[i+1])
            {
                r=j;
                break;
            }
        }
        n1=q-PK1;
        n1=n1%16;
        if(n1<0)
        n1+=16;
        n2=r-PK1;
        n2=n2%16;
        if(n2<0)
        n2+=16;
        ByteCode=(n1*16)+n2;
        DecryptedData[ctr++]=(char)ByteCode;
    }

    DecryptedData[ctr]='\0';
    //cout<<"Start:";
    //cout<<DecryptedData;
    fprintf(fp,"%s",DecryptedData);
    fclose(fp);
    cout<<endl;
}
/******************/

/********SERVER SIDE COMPUTATION*********/
long long* ServerSideComputation(char *tempdata,long long PK,long long PK2)
{
    FILE *fp;
    long long ctr=0;
    long long Key2;
    long long PKey2;
    char AUT[11],FT[11],INTR[11];
    char data[1000000];
    int read;
    //fp=fopen("filetobeencrypted.txt","r");
    fp=fopen("filetest2.txt","r");
    cout<<endl<<"ENCRYPTION BY SENDER"<<endl;
    //fp=fopen("filetest.txt","r");
    read = getc(fp) ;
    while (read!= EOF)
    {
        data[ctr]=read;
        ctr++;
   		read=getc(fp);
    }
    //cout<<"Primer Length: "<<ctr-1<<endl;
    fclose(fp);
    Key2=ctr;
    PKey2=Key2^PK2;

    long long E,R;   //PK:Public Key, E:Encryption key, R:Random number
    long long PKeys[3];
    long long r,c;   //L1PK:Level 1 Private Key, r:Remainder computation, q:Quotient computation

    R=(long long)rand()*(long long)rand()*(long long)rand();
    //R=rand()*rand();
    //R=30000;
    cout<<"R="<<R<<endl;
    E=BinaryCompliment(R);
    cout<<"E="<<E<<endl;

    r=(PK*R)%16;
    c=(PK*R)/16;
    PKeys[0]=r;
    PKeys[1]=c;
    PKeys[2]=PKey2;
    cout<<"Key for Encryption Level 1= "<<E<<endl;
    cout<<"Key for Encryption Level 2= "<<Key2<<endl;
    //cout<<"Level 1 private key in parts, to be sent to receiver: "<<PKeys[0]<<" and "<<PKeys[1]<<endl<<endl;
    ProcedureEncryptionLevel1(E,data,tempdata);  //ENCRYPTION OF DATA IN THE SERVER (LEVEL 1)
    ProcedureEncryptionLevel1(E,"12345",AUT);   //Encryption of the Authentication code
    ProcedureEncryptionLevel1(E,"65789",FT);    //Encryption of the FileType code
    ProcedureEncryptionLevel1(E,"abcde",INTR);  //Encryption of the Integrity code
    ProcedureEncryptionLevel2(Key2,tempdata,tempdata,AUT,FT,INTR);  //Level 2 Encryption
    return PKeys;
}
/*****************************************************/

/***********RECEIVER SIDE COMPUTATION***********/
void ReceiverSideComputation(long long PK,long long *lpk, char* tempdata,long long PK2)
{
    long long r,c;
    long long X,K1; //X:Decimal Value computation, K1:Intermediate key computation
    long long Key2;

    r=lpk[0];
    c=lpk[1];
    Key2=lpk[2]^PK2;
    X=(16*c)+r;
    K1=(X/PK);

    cout<<endl<<endl<<"DECRYPTION BY RECEIVER"<<endl;
    //cout<<"Decryption Keys ="<<K1<<endl<<BinaryCompliment(K1)<<endl<<endl;
    ProcedureDecryption(BinaryCompliment(K1),tempdata,Key2);          //DECRYPTION OF DATA IN THE RECEIVER
}
/********************************************************/

int main()
{
    long long *L1PK,PK1;
    char check;
    long long PK,PK2;
    static char tempdata[1000000];
    srand(time(NULL));

    do
    {
        do
        {
            PK=ExchangeKeys();
        }while((PK==1)||(PK<0));
        cout<<"LEVEL 1 ENCRYPTION KEY ACCEPTED BY SENDER AND RECEIVER = ";
        cout<<PK<<endl;
         do
        {
            PK2=ExchangeKeys();
        }while((PK2==1)||(PK2<0));
        //cout<<"LEVEL 2 ENCRYPTION KEY ACCEPTED BY SENDER AND RECEIVER = ";
        //cout<<PK2<<endl<<endl;
        L1PK=ServerSideComputation(tempdata,PK,PK2);    //SERVER SIDE COMPUTATION
        ReceiverSideComputation(PK,L1PK,tempdata,PK2);   //RECEIVER SIDE COMPUTATION
        cout<<"\nRun Once Again? y/n\n";
        cin>>check;
    }
    while(check=='y');
    return 0;
}
